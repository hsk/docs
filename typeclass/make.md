# アドホック多相下でのアドホックの作り方

  http://www.cse.iitk.ac.in/users/karkare/courses/2010/cs653/Papers/ad-hoc-polymorphism.pdf

  Philip Wadler and Stephen Blott

  University of Glasgow

  October 1988

## Abstract

  本論文では、型クラス、アドホック多相への新しいアプローチを提示します。
  型クラスは、乗算などの算術演算子のオーバーロードを許可し、Standard MLの「`eqtype` 変数」を一般化します。
  型クラスはHindley/Milner多相型システムを拡張し、オブジェクト指向プログラミング、有界型定量化、および抽象データ型で発生する問題への新しいアプローチを提供します。
  本稿では、クラスを入力するための非公式の導入を提供し、型推論規則によって正式にそれらを定義します。

## 1 イントロダクション

  Stracheyは、二種類の多相型を区別するために、アドホックとパラメトリックの形容詞を選択した <a name="r_Str67"></a>[\[Str67\]](#Str67)。
  アドホック多相は、関数が定義されている場合に発生します。いくつかの異なる型に対して、型ごとに異なる方法で動作します。
  典型的な例は、オーバーロードの乗算です。
  同じシンボルを使用して整数の乗算(`3 * 3`のように)と浮動小数点値の乗算(`3.14 * 3.14`のように)を表すことができます。
  パラメトリック多相は、関数が定義されている場合に発生します。ある範囲の型に対して、各型に対して同じように作用します。
  典型的な例は長さ関数であり、これは整数のリストと浮動小数点数のリストで同じように動作します。

  ----

  \*著者の所在地：スコットランド、グラスゴー大学、グラスゴーG12 8QQ)コンピューティングサイエンス学科。

  電子メール：wadler, blott@cs.glasgow.ac.uk。

  Published in： 1989年1月、テキサス州オースティン、プログラミング言語の原則に関する第16回ACMシンポジウム。

  この資料の全部または一部を無償でコピーすることが許可されるのは、コピーが直接的な商業的利益のために作成または配布されていない場合、ACMの著作権表示と出版のタイトルと日付が表示され、コピーが 計算機協会の許可を得ている。
  そうでなければコピーするか、または再発行するには、料金および/または特定の許可が必要です。

  ----

  パラメトリック多相型に対する広く受け入れられているアプローチの1つは、Standard ML [<a name="r_HMM86"></a>[HMM86](#HMM86), <a name="r_Mil87"></a>[Mil87](#Mil87)]、Miranda<a name="r1"></a>[1](#1) <a name="r_Tur85"></a>[\[Tur85\]](#Tur85) および他の言語で使用されるHindley/Milner型システム[<a name="r_Hin69"></a>[Hin69](#Hin69), <a name="r_Mil78"></a>[Mil78](#Mil78), <a name="r_DM82"></a>[DM82](#DM82)]です。
  一方、アドホック多相型には広く受け入れられているアプローチがないため、その名前は二重に適切です。
  本稿では、Hindley/Milner型システムを拡張して特定の種類のオーバーロードを含む型クラスを提供し、Strachey分離された2種類の多相型をまとめます。
  ここで提示された型システムは、Hindley/Milner型システムの一般化です。 そのシステムのように、型宣言が推論できるので、関数の明示的な型宣言は必要ありません。
  推論プロセス中に、型クラスを使用するプログラムを、オーバーロードを使用しない同等のプログラムに変換することができます。
  変換されたプログラムは、(一般化されていない)Hindley/Milner型システムで型付け可能です。
  この論文の本文では、型クラスと変換ルールの非公式な紹介がありますが、付録では、型定義と変換の正式なルールを推論ルールの形で示しています(<a name="r_DM82"></a>[\[DM82\]](#DM82)のように)。
  変換規則は、型クラスのセマンティクスを提供します。
  また、必要に応じてプリプロセッサを記述するだけで、新しいシステムをHindley/Milner型の既存の言語に追加することもできます。
  アドホック多相性の問題が生じる2つの場所は、算術と等価性のための演算子の定義です。
  以下では、Standard MLとMirandaによって採用されたこれらの3つの問題へのアプローチを検討します。 2つの言語間でアプローチが異なるだけでなく、単一の言語でも異なっています。
  しかし、我々が見るように、型クラスはこれらの問題に対処できる一様なメカニズムを提供します。

  ----

  <a name="1"></a>[1](#r1) MirandaはResearch Software Limitedの商標です。

  ----

  この作業は、Lasky Functional Programming Language <a name="2"></a>[2](#2) を設計するHaskell委員会の努力から生まれました。
  ハスケル委員会の目標の1つは、可能な限り問題に対処するための「オフザシェルフ」ソリューションを採用することでした。
  算術と等価性は、標準的な解が得られなかった分野であることを認識するのに少し驚きました！
  型クラスは、これらの問題のより良い解決策を見つける試みとして開発されました。 ソリューションはHaskellの設計に含まれるのに十分成功したと判断されました。
  ただし、型クラスはHaskellから独立して判断する必要があります。 Standard MLのような別の言語に組み込むこともできます。
  型クラスは、オブジェクト指向プログラミング、型の限定量化、抽象データ型 [<a name="r_CW85"></a>[CW85](#CW85), <a name="r_MP85"></a>[MP85](#MP85), <a name="r_Rey85"></a>[Rey85](#Rey85)] で発生する問題と密接に関連しているようです。
  接続のいくつかは以下に概説されていますが、これらの関係を完全に理解するためにより多くの作業が必要です。
  我々と非常によく似た型システムはStefan Kaes <a name="r_Kae88"></a>[\[Kae88\]](#Kae88) によって独立して発見されました。
  我々の仕事は、Kaesのいくつかの点で改善されています。特に、関連する演算子をグループ化するための型クラスを導入し、より良い変換方法を提供します。
  この論文は2つの部分に分かれています。本文は型クラスを非公式に紹介していますが、付録にはより正式な説明があります。
  2章では、Standard MLとMirandaで使用されているようなアドホック多相型の限界を記述することにより、新しいシステムを動機づけます。
  セクション3では、簡単な例を用いて型クラスを紹介します。
  セクション4は、セクション3の例が型クラスなしで同等のプログラムにどのように変換されるかを示しています。
  セクション5は、オーバーロードされた等価関数の定義である2番目の例を示しています。
  セクション6では、サブクラスについて説明します。
  第7章では、関連する作業と結論について説明します。
  付録Aは、入力と変換の推論規則を示しています。

  -------

  <a name="2"></a>[2](#r2) ハスケル委員会には、Arvind、Brian Boutel、Jon Fairbairn、
  ジョー・ファッセル、ポール・フダク、ジョン・ヒューズ、トーマス・ジョンソン、ディック・キーバーツ、
  サイモン・ペイトン・ジョーンズ、リシュユール・ニッヒル、マイク・リーブ、フィリップ・ワドラー、デイヴィッド
  ワイズ、ジョナサン・ヤング。

  -------

## 2 アドホック多相型の限界

  このセクションは、スタンダードMLと Miranda で算術と等価性によって生じる問題を調べることによって、アドホック多相型の処理を動機づけます。

#### 算術

  オーバーロードに対する最も単純なアプローチでは、加算や乗算などの基本的な演算はオーバーロードされますが、それらの観点から定義された関数はオーバーロードされません。
  たとえば、 `3 * 3` や `3.14 * 3.14` と書くことはできますが、定義することはできません

    square x = x * x

  次に、

    square 3
    square 3.14

  これがStandard MLで取られたアプローチです。
  (ちなみに、Standard MLには算術演算子のオーバーロードが含まれていますが、その正式な定義は、このオーバーロードがどのように解決されたかについて、意図的にあいまいです[<a name="r_HMT88"></a>[HMT88](#HMT88), page 71]
  Standard MLのバージョンでは異なる方法でオーバーロードが解決されます)。

  より一般的なアプローチは、上記の方程式が、 `Int -> Int` と `Float -> Float` 型の2つのオーバーロードされた`squares`の定義を表すことを可能にすることです。
  しかし、関数を考えてみると：

    squares (x, y, z)
        = (square x, square y, square z)

  `x`、 `y`、および `z` のそれぞれは独立して `Int` 型または `Float` 型のいずれかを持つことができるため、この関数のオーバーロードされたバージョンは8つあります。
  一般に、変換の数が指数関数的に増加している可能性があり、これがそのような解が広く使われていない理由の1つです。

  Miranda では、この問題は、算術演算をオーバーロードしないことによって回避されます。
  Mirandaは浮動小数点型(「`num`」という名前)のみを提供し、演算が整数に制限されていることを示すために型システムを使用する方法はありません。

#### 等価性

  等価操作の履歴は検査されています。
  オーバーロードされ、完全に多態的で、部分的に多態的なものとして扱われています。

  等価性への最初のアプローチは、乗算のように、それをオーバーロードにすることです。
  特に、等価性を認めるすべてのモノ型、すなわち、抽象型または関数型を含まないすべてのモノ型で、等価性がオーバーロードされる可能性があります。
  そのような言語では、整数を超える等価性を表すために `3 * 4 == 12`、文字に対して等価性を表すために `'a' == 'b'` と書くことができます。
  しかし、方程式によって関数 `member` を定義することはできません

    member [] y       = False
    member (x : xs) y = (x == y) \/ member xs y

  次に、

    member [1,2,3] 2
    member "Haskell" 'k'

  (文字のリスト `['a', 'b', 'c']` を `"abc"` と略記します)。
  これは、Standard ML <a name="r_Mil84"></a>[\[Mil84\]](#Mil84) の最初のバージョンで取られたアプローチです。

  第2のアプローチは、完全な多相型を等価性にすることです。
  この場合、その型は次のとおりです。

    (==) :: a -> a -> Bool

  ここで、 `a`はすべての型に渡る型変数です。
  `member` 関数の型は今

    member :: [a] -> a -> Bool

  です。("aのリスト"の型に対して`[a]`と書く)
  つまり、関数や抽象型に等しい値を適用しても型エラーは発生しません。
  これは Miranda で取られたアプローチです。関数型に等価が適用された場合、結果は実行時エラーです。 抽象型に等価が適用された場合、その結果は表現が等しいかどうかをテストすることになります。
  この最後は、抽象化の原則に違反するバグと見なされるかもしれません。

  第3のアプローチは、限定的な方法で等価性多相型を作ることです。
  この場合、その型は次のとおりです。

    (==) :: a(==) -> a (==)-> Bool

  ここで、 `a(==)` は、等価性を認める型以上の範囲の型変数です。

  `member` 関数の型は今

    member :: [a(==)] -> a(==)-> Bool

  です。関数型または抽象型に等価または `member` を適用すると、型エラーになります。
  これは、Standard MLで現在取られているアプローチであり、 `a(==)` は「`a`」と書かれ、「`eqtype` 変数」と呼ばれます。

  多態的な等価性は、ランタイムシステムの実装者に特定の要求を課します。
  たとえば、Standard MLでは、参照型は他の型とは異なるように等価性がテストされるため、実行時に参照を他のポインタと区別することができなければなりません。

  オブジェクト指向プログラミング。
  抽象型に対してユーザー定義の等価操作を含めるために多態性の等価性を拡張できるといいでしょう。
  これを実装するには、すべてのオブジェクトにメソッドへのポインタ、つまり同等性テストを実行するプロシージャを指定する必要があります。
  このプロパティで複数の操作を行う場合は、各オブジェクトに適切なメソッドの辞書へのポインタを渡す必要があります。
  これはまさにオブジェクト指向プログラミング <a name="r_GR83"></a>[\[GR83\]](#GR83) で使われているアプローチです。

  多相同値の場合、これは、等価関数の両方の引数に同じ辞書へのポインタが含まれることを意味します
  (両方とも同じ型なので)。
  これは、おそらく辞書がオブジェクトとは独立して渡されるべきであることを示唆しています。 現在、多形性の等価性には、1つの辞書と2つのオブジェクト(辞書を除く)が渡されます。
  これは、ここで説明する型クラスと変換メソッドの背後にある直感です。

## 3 導入の例

  ここでは、例を使って型クラスを紹介します。

  Int型とFloat型をオーバーロード `(+)`、 `(*)`、 `negate` (単項式マイナス)したいとします。
  これを行うには、図1のクラス宣言に示すように、 `Num` という新しい型のクラスを導入します。
  この宣言は、"適切な型の`(+)`、 `(*)` および `negate` という名前の関数が定義されている場合は、型 `a` がクラス `Num` に属している"と述べることができます。

  図1の2つのインスタンス宣言に示すように、このクラスのインスタンスを宣言できるようになりました。
  アサーション `Num Int` は "`Int` で定義された適切な型の `(+)`、 `(*)`、 `negate` という名前の関数があります"と読むことができます。
  インスタンス宣言は、3つの関数に適切なバインディングを与えることによって、このアサーションを正当化します。
  型推論アルゴリズムは、これらのバインディングが適切な型を持つこと、すなわち、 `addInt` 型が `Int -> Int -> Int` 型であり、同様に `mulInt` 型と `negInt` 型であることを検証する必要があります。
  (`addInt`、 `mulInt`、および `negInt` は標準的なプレリュードで定義されていると仮定します)。
  インスタンス `Num Float` も同様に宣言されます。

  表記法に関する注意： 型クラス名と型コンストラクタ名は大文字で始まり、型変数名は小文字で始まります。
  ここで、`Num` は型クラスであり、 `Int` と `Float` は型コンストラクタであり、 `a` は型変数です。

  ここで、

    square x = x + x

  この定義から`square` の型を推論できるアルゴリズムが存在します(付録で概説されています)。
  型を導出します:

    square :: Num a => a -> a

  ----

    class Num a where
      (+), (*) :: a -> a -> a
      negate   :: a -> a

    instance Num Int where
      (+)    = addInt
      (*)    = mulInt
      negate = negInt

    instance Num Float where
      (+)    = addFloat
      (*)    = mulFloat
      negate = negFloat

    square   :: Num a => a -> a
    square x = x * х

    squares           :: Num a, Num b, Num c => (a, b, c) -> (a, b, c)
    squares (x, y, z) =  (square x, square y, square z)

  図1：算術演算の定義

    data NumD a = NumDict (a -> a -> a) (a -> a -> a) (a -> a)

    add (NumDict a m n) = a
    mul (NumDict a m n) = m
    neg (NumDict a m n) = n

    numDInt   :: NumD Tnt
    numDInt   =  NumDict addInt mulInt negInt
    numDFloat :: MumD F1oat
    numDFloat =  NumDict addFloat mulFloat negFloat

    square'         :: NumD a -> a -> a
    square' numDa X =  mul numDa X X

    squares' :: (NumD a, NumD b, NumD c) -> (a,b,c) -> (a,b,c)

    squares' (numD a, numD b, numD c) (x, y, z)
        = (square' numDa x, square' numDb y, square' numDc z)

  図2： 算術演算の変換

  これは、"`square` は、 `a` がクラス `Num` に属するような(すなわち、 `(+)`、 `(*)`、 および `nagate` が `a` に定義されるような)すべての`a`に対して、 `a -> a` 型を有する。"とよみます。

  ここで、

    square 3
    square 3.14

  適切な型がそれぞれに導出されます(最初の式のInt、2番目の式の `Float`)。
  一方、`square 'x'` と書くと、コンパイル時に型エラーが発生します。これは、 `Char` が(インスタンス宣言によって)数値型であると宣言されていないためです。

  最後に、前述の関数 `squares` を定義すると、図1に示す型が推論されます。
  この型は、`a`、 `b`、および `c` がクラス`Num` "に属すように、すべての`a`、 `b`、および `c` に対して「`square` に型 `(a,b,c) -> (a,b,c)` があります。」
  (`a`、 `b` 、 `c` の直積である型については `(a,b,c)` と書きます。)
  よって `squares` は8つの型ではなく1つの型です。
  以下の項

    squares (1, 2, 3.14)

  は適法であり、適切な型を導出します。

## 4 変換

  この形式のオーバーロードの特徴の1つは、コンパイル時に、クラス宣言およびインスタンス宣言を含むプログラムを、そうでない同等のプログラムに変換することが可能であることです。
  同等のプログラムは有効なHindley/Milner型を持つでしょう。

  変換方法は、例を用いて説明します。
  図2は、図1の宣言の変換を示しています。

  各クラス宣言に対して、そのクラスの適切な「メソッド辞書」に対応する新しい型と、辞書内のメソッドにアクセスする関数を導入します。
  この場合、クラス `Num` に対応して、図2に示すような型 `NumD` を導入します。
  データ宣言は、 `NumD` を新しい型の型コンストラクタとして定義します。
  この型の値は、値コンストラクタ `NumDict` を使用して作成され、示された型の3つのコンポーネントを持ちます。
  関数 `add`、 `mul`、および `neg` は、 `NumD` 型の値をとり、それぞれ第1、第2、第3成分を返します。

  `Num` クラスの各インスタンスは、 `NumD` 型の値の宣言に変換されます。
  したがって、インスタンス `Num Int` に対応して、 `NumD Int` 型のデータ構造体を宣言し、同様に `Float` 型についてもデータ構造体を宣言します。

  `x + y`、 `x * y`、 および `negate x` という形式の各項は、次のように対応する項に置き換えられます。

    x+y      --> add numD x y
    х*у      --> mul numD x y
    negate x --> neg numD x

  `numD` は適切な辞書です。
  適切な辞書はどのように決定されていますか？
  その型によって。
  たとえば、次のような変換があります。

    3 + 3
      --> mul numDInt 3 3

    ​3.14 + 3.14
      --> mul numDFloat 3.14 3.14

  最適化として、コンパイラがベクタ縮約を実行して `mulInt 3 3` と `mulPloat 3.14 3.14` にそれぞれ変換するのは簡単です。

  関数の型にクラスが含まれている場合、これは実行時に渡される辞書に変換されます。
  たとえば、その型の `square` の定義を次に示します

    square   :: Num a => a -> a
    square x =  x * x

  これは

    square'        :: NumD a -> a -> a
    square' numD x =  mul numD x x

  `square` の各アプリケーションは、適切な余分なパラメータを渡すために変換する必要があります：

    square 3
      --> square' numDInt 3
    square 3.2
      --> square' numDFloat 3

  最後に、`square` の変換も図2に示されています。
  型が8種類ではなく1種類があるのと同様に、8種類ではなく1種類の変換しかありません。
  指数関数的な成長は避けられます。

## 5 さらなる例： 等価性

  このセクションでは、クラス宣言とインスタンス宣言を使用して等価を定義する方法を示します。
  型クラスは、Standard MLで使用される "`eqtype` 変数"の直接的な一般化として役立ちます。
  標準的なMLとは異なり、このメカニズムにより、ユーザは、抽象的な型に対して等価性を直接的に拡張できます。
  また、Standard MLとは異なり、このメカニズムはコンパイル時に変換されるため、ランタイムシステムの実装者に特別な要求はありません。

    class Eq a where
      (==) :: a -> a -> bool

    instance Eq Int where
      (==) = eqInt

    instance Eq Char Where
      (==) = eqChar

    member            :: Eq a => [a] -> a -> Bool
    member [] y       =  False
    member (x:xs) y   =  (x == y) \/ member xs y

    instance Eq a, Eq b => Eq (a,b) where
      (u,v) == (x,y)  = (u == x) & (v == y)

    instance Eq a => Eq [a] where
      [] == []        = True
      [] == y:ys      = False
      x:xs == []      = False
      x:xs == y:ys    = (x == y) & (xs == ys)

    data Set a = MkSet [a]

    instance Eq a => Eq (Set a) where
        MkSet xs == MkSet ys = and (map (member xs) ys)
                        & and (map (member ys) xs)

  図3： 等価性の処理以上の改善を提供します。

    data EqD a      = EqDict (a -> a -> Bool)

    eq (EqDict e)   = e

    eqDInt          :: EqD Int
    eqDInt          =  EqDict eqInt

    eqDChar         :: EqD Int
    eqDChar         =  EqDict eqChar

    member'                         :: EqD a -> [a] -> [a] -> Bool
    member' eqDa [] y               =  False
    member' eqDa (x:xs) y           = eq eqDa x y \/ member' eqDa xs y

    eqDPair                         :: (EqD a, EqD b) -> EqD (a,b)
    eqDPair (eqDa,eqDb)             =  EqDict (eqPair (eqDa,eqDb))

    eqPair                          :: (EqD a, EqD b) -> (a,b) -> (a,b) -> Bool
    eqPair (eqDa,eqDb) (x,y) (u,v)  =  eq eqDa x u & eq eqDb y v

    eqDList                         :: EqD a -> EqD [a]
    eqDList eqDa                    =  EqDict (eqList eqDa)

    eqList                          :: EqD a -> [a] -> a -> Bool
    eqList eqDa [] []               =  True
    eqList eqDa [] (y:ys)           =  False
    eqList eqDa (x:xs) []           =  False
    eqList eqDa (x:xs) (y:ys)       =  eq eqDa x y & eq (eqDList eqDa) xs ys

  図4: 等価性の変換

  定義は図3に要約されています。
  まずこのクラスの単一の演算子 `(==)` とインスタンス `Eq Int` と `Eq Char` を含むクラス `Eq` を宣言します。

  次に、図3に示すように、通常の方法で `member` 関数を定義します。
  `member` の型は、推論できるので、明示的に指定する必要はありません。
  推論される型は：

    member :: Eq. a => [a] -> a -> Bool

  これは「`member` はクラス `Eq` にある `a` がすべての型 `a` に対して(すなわち、等式がaで定義されるように) 型 `[a] - > a - > Bool` を持つ。」と読みます。
  (これは、 `''a` が "`eqtype` 変数"である Standard ML の型 `''a list->''a->bool` とまったく同じです。)

  我々は今、両方とも `True` と評価される

    member [1,2,3] 2
    member "Haskell" 'k'

  のような項を書くことができます。

  次に、ペアを介して等価を定義するインスタンスを与えます。
  このインスタンスの最初の行には、
  "`a` がクラス `Eq` にあり、 `b`がクラス `Eq` にあるようなすべての`a`と`b`について、ペア `(a,b)` もクラス `Eq` にあります"。
  言い換えれば、「`a`に等価性が定義され、`b`に等価性が定義されている場合、等価性は `(a,b)` 上で定義されます。」
  インスタンスは、通常の方法で、2つのコンポーネントの等価性の観点から、ペアの等価性を定義します。

  同様に、リストの上に等価性を定義することも可能です。
  このインスタンスの最初の行は、 "`a` に等価性が定義されている場合、 `a` の型リストに等価性が定義されます。"
  ここでは、

    "hello" == "goodbye"
    [[1,2,3], [4,5,6]] == []
    member ["Haskell", "Alonzo"] "Moses"

  これらはすべて `False` と評価されます。

  最終的なデータ宣言は、新しい型コンストラクタ `Set` と新しい値コンストラクタ `MkSet` を定義します。
  モジュールが `Set` をエクスポートするが `MkSet` を隠すと、モジュールの外部では `Set`の表現にアクセスできなくなります。
  これは抽象データ型を定義するためにHaskellで使用されるメカニズムです。
  最終的なインスタンスは、セットに対する等価性を定義します。
  このインスタンスの最初の行は、 "等価性が `a` に定義されている場合、等価性は型 '`a` の集合' に定義されます"。

  この場合、集合はリストの形で表現され、2つの集合は、第1の `member` のすべての `member` が第2の `member` の `member` であれば等しくなるように取られ、逆も同様です。
  (この定義では、リストのすべての要素に関数を適用する標準関数マップを使用し、および、ブール値のリストの連結を返します。)
  集合の等価性が `member` の項で定義され、 `member` はオーバーロードされた等価性を使用しているので、
  整数、整数のリスト集合、および整数の組の偶数組の集合に等価性を適用することが有効です。

  この最後の例は、型クラス・メカニズムがオーバーロードされた関数を抽象データ型に対して自然な方法で定義する方法を示しています。
  特に、これは、Standard ML、または Miranda で提供される平等の処理以上の改善を提供します。

### 5.1 等価性の変換

  ここでは、変換メカニズムが等価性の例にどのように適用されるかを検討します。

  図4は、図3の宣言の変換を示しています。
  変換の最初の部分は何も新しく導入されておらず、第4章の変換に似ています。

  まず、クラス `Eq` に対応する辞書 `EqD` を定義します。
  この場合、クラスには1つの操作 `(==)` のみが含まれているため、辞書には1つのエントリしかありません。
  セレクタ関数 `eq` は型 `EqD a` の辞書をとり、型 `a -> a -> Bool` の1つのエントリを返します。
  インスタンス `Eq Int` と `Eq Char` に対応して、適切な等価関数を含む `EqD Int` 型と `EqD Char` 型の2つの辞書を定義し、
  関数メンバを直接 '`member`' に変換します。

  ここに3つの用語とその変換があります：

    3*4 == 12
      -->  eq eqDInt (mul numDInt 3 4) 12

    member [1,2,3] 2
      -->  member' eqDInt [1,2,3] 2

    member "Haskell" 'k'
      --> member' eqDChar "Haskell" 'k'

  リストに対する等価性のためのインスタンス宣言の変換は少し難解です。
  インスタンスの宣言が始まることを思い出してください

    instance Eq a => Eq [a] where
        ...

  これは、等価が定義されている場合に型 `[a]` に対して等価が定義されることを示します。
  これに対応して、型 `[a]` のインスタンス辞書は、型 `a` の辞書によってパラメータ化されているため、型

    eqDList :: EqD a -> EqD [a]

  残りの変換は図4に示されており、対での等価性の変換も同様です。
  ここに3つの用語とその変換があります：

    "hello" == "goodbye"
      --> eq (eqDList eqDChar)
              "hello"
              "goodbye"

    [[1,2,3], [4,5,6]] == []
      --> eq (eqDList (eqDList eqDInt))
              [[1,2,3], [4,5,6]]
              []

    member ["Haskell", "Alonzo"] "Moses"
      --> member' (eqLList eqDChar)
            ["Haskell", "Alonzo"]
            "Moses"

  最適化として、コンパイラーは、 `eq(eqDList eqD)` 形式の項を `eqList eqD` に変換するためにベータ簡約を実行することは簡単です。ここで、 `eqD` は等価の辞書です。
  この最適化は、上記の最初の2つの例に適用され、図4の `eqList` 自体の定義にも適用されます。

  この変換技法の効率を、 Standard ML または Miranda に見られるような多相型等価性と比較することは価値があります。
  `eqInt` などの個々の演算は、引数の型が事前に分かっているため、多態性の等価性よりも若干効率的です。
  一方、 `member` や `eqList` などの操作では、ポリモーフィックな等価性が回避するオーバーヘッドを明示的に渡す必要があります。
  これらのコストのトレードオフを評価するには、さらなる経験が必要です。

## 6 サブクラス

  前の説明では、`Number` と `Eq` は完全に別のクラスとみなされていました。
  数値演算と等価演算の両方を使用したい場合、これらはそれぞれ型に別々に現れます：

    memsq      :: Eq a, Num a => [a] -> a -> Bool
    memsq xs x =  member xs (square x)

  現実的には、 `(+)`、 `(*)` 、およびそれに定義された`negate` `(==)` も定義されていると予想されます。 逆ではありません。
  したがって、`Num`を式のサブクラスにすることは合理的です。

  我々は次のようにこれを行うことができます：

    class Eq. a => Num a where
      (+)    :: a -> a -> a
      (*)    :: a -> a -> a
      negate :: a -> a

  これは、 `a` がクラス `Eq` にも属している場合にのみ、 `a` がクラス `Num` に属している可能性があることを主張します。
  言い換えれば、 `Num` は `Eq` のサブクラスであり、等価的に `Eq` は `Num` のスーパークラスです。
  インスタンス宣言は以前と同じですが、インスタンス宣言 `Num Int` は、同じスコープ内でインスタンス宣言 `Eq Int` がアクティブな場合にのみ有効です。

  このことから、型が `Num a` を含むときはいつでも、それは `Eq a` も含まなければならないことになります。 したがって、便利な省略形として、 `Num a` が存在するときは常に `Eq a` を型から省略することができます。
  したがって、 `memsq` の型については、

    memsq :: Num a => [a] -> a -> Bool

  修飾子 `Eq a` は `Num a` によって暗示されるので、もはや言及する必要はありません。

  一般に、各クラスは任意の数のサブクラスまたはスーパークラスを持つことができます。
  ここには工夫した例があります：

    class Top a Where
      fun 1 :: a -> a

    class Top a => Left a where
      fun2 :: a -> a

    class Top a => Right a where
      fun3 :: a -> a

    class Left a, Right a => Bottom a
      where
      fun4 :: a -> a

  これらの型間の関係は、次のように図式化することができます。

        Top
      /     \
    Left   Right
      \     /
       Bottom

  複数のスーパークラスは、オブジェクト指向言語を実装する通常の手段にいくつかの問題を提起しますが、ここで概説した変換スキームには問題はありません。
  変換は、実行時に適切な辞書が渡されることを保証するだけです。 いくつかのオブジェクト指向システムのように特別なハッシング・スキームは必要ありません。

## 7 結論

  各インスタンスが満たさなければならないプロパティを指定して、クラス宣言にアサーションを追加することは当然考えられます。

    class Eq a Where
      (==) :: a -> a -> Bool
      % (==) is an equivalence relation

    class Num a Where
        zero, one :: a
        (+), (*) a -> a -> a
        negate a -> a
        % (zero, one, (+), (*), negate)
        %   form a ring

  これらのプロパティに依存する証明は、各インスタンス宣言ごとに保持されていることが証明されている限り有効です。ここでアサーションは単にコメントとして書かれています。より洗練されたシステムではおそらくそのようなアサーションを検証したり使用したりすることができます。
  これは、クラス宣言がOBJ <a name="r_FGJM85"></a>[\[FGJM85\]](#FGJM85) のオブジェクト宣言に似るようになるため、クラスとオブジェクト指向プログラミングの関係を示唆しています。

  上の例では、ゼロや1などのオーバーロードされた定数を持つことができます。
  ただし、定数の無制限オーバーロードは、余分な型情報を提供しないとオーバーロードを解決できない状況につながります。
  たとえば、結果が `Int` か `Float` かを指定するコンテキストで使用されていなければ、 `* 1` という式は無意味です。
  このため、このドキュメントでは、オーバーロードされていない定数を使用するよう注意しており:
  `3` は `Int` 型、 `3.14` は`Float`型です。
  より一般的な定数の扱いは、部分型間の強制を必要とするようです。

  クラスを複数の型変数に適用できるようにすることは合理的です。
  たとえば、

    class Coerce a b where
      coerce :: a -> b

    instance Coerce Int Float where
      coerce = convertIntToFloat

  この場合、アサーション `Coerce a b` は、 `a` が `b` の部分型であるというアサーションと同等と見なすことができます。
  これは、この研究と有界定量化と部分型に関する研究との関係を示唆している(この領域における優れた調査のための[<a name="r_CW85"></a>[CW85](#CW85), <a name="r_Rey85"></a>[Rey85](#Rey85)]および最近の研究のための[<a name="r_Wan87"></a>[Wan87](#Wan87), <a name="r_Car88"></a>[Car88](#Car88)]参照)。

  型クラスは、型変数がインスタンス化される型を制限する一種の有界量化子と考えることができます。
  しかし、有界量化への他のアプローチとは異なり、型クラスは暗黙の強制変換を導入しません
  (部分型 `Int` からスーパー型 `Float` へ、またはフィールド `x`、 `y`、 `z` を持つレコードからフィールド `x` と `y` を持つレコードに変換するなど)。
  型クラスとこれらの他のアプローチとの間の関係のさらなる探求は、実りあるものになる可能性が高いのです。

  型クラスは、一種の抽象データ型と考えることもできます。
  各型クラスは、関数とその型のコレクションを指定しますが、実装する方法は指定しません。
  ある種の型クラスは、多くの実装を持つ抽象データ型に対応し、各インスタンス宣言に1つずつ対応します。
  ここでも、抽象データ型[<a name="r_CW85"></a>[CW85](#CW85), <a name="r_MP85"></a>[MP85](#MP85), <a name="r_Rey85"></a>[Rey85](#Rey85)]に対する型クラスと現在の作業との関係の探求が求められているようです。

  我々はすでにKaesの仕事を参照しました。
  我々の仕事の進歩の1つは、オーバーロードされた関数をクラスにグループ化する概念的で表記上の利点です。
  さらに、我々のシステムはより一般的です。 Kaesは、上の例のような複数の型変数を含むオーバーロードを処理することはできません。
  最後に、我々の変換ルールは彼の改善です。
  Kaesは、2つの変換ルール(「セマンティクス」と呼ぶ)、つまり静的ルールと動的ルールの2つのセットを概説します。
  彼のダイナミックセマンティクスは、ここで説明する言語よりも制限されています。彼の静的セマンティクスは似ているように見えますが、ここで説明する変換とは異なり、プログラムのサイズを大幅に増やすことができます。

  変換メソッドの1つの欠点は、実行時にメソッド辞書に対応して渡される新しいパラメータを導入することです。
  部分的な評価 <a name="r_BEJ88"></a>[\[BEJ88\]](#BEJ88) を使用して特定の辞書に特化した関数のバージョンを生成することによって、これらのコストの一部を排除することは可能かもしれません。 これにより、コードサイズが増加する犠牲を払って実行時間が短縮されます。
  我々のアプローチ(部分的な評価の有無にかかわらず)と他の手法とのトレードオフを評価するためには、さらなる研究が必要です。

  上記から明らかなように、多くの問題が引き続き検討されており、多くのトレードオフが依然として評価されています。
  Haskellが提供する型クラスの実践的な経験を楽しみにしています。

## 謝辞

  関数の型にオーバーロードが反映される可能性があるという重要な考えは、Joe Faselによって(別の形式で)提案されました。
  議論やコメントについては、Luca Cardelli、Bob Harper、Paul Hudak、John Hughes、Stefan Kaes、John Launchbury、John Mitchell、Kevin Mitchell、Nick Rothwell、Mads Tofte、David Watt、Haskell委員のメンバーにも感謝しています。 、およびIFIP 2.8のメンバー。

## A タイピングルールと変換ルール

  この付録では、形式的な型付け規則と変換規則を示し、型付けと変換の両方を実行する1組の規則について説明します。
  このルールは、DamasとMilner <a name="r_DM82"></a>[\[DM82\]](#DM82) によって与えられたルールの拡張です。

## A.1 言語

  オーバーロードのためのタイピングと変換のルールを提示するには、基本的な問題を取り上げるやや簡単な言語を使用すると便利です。
  通常の構文(識別子、関数適用、ラムダ抽象化、let式)を持つ言語に加えて、クラス宣言とインスタンス宣言にそれぞれ対応する2つの新しい構文 `over` と `inst` 式を使用します。
  式と型の構文は図5に示されています。

  `over` の式は

    over x :: σ in e

  オーバーロードされた識別子であると宣言します。
  この宣言の範囲内で、一つ以上の対応する `inst` 式があるかもしれません

    inst x :: σ' = e0 in e1

  ここで、型 `σ'` は、型 `σ` (後で正確になる概念)の実体(instance)です。
  ラムダとlet式とは異なり、 `over` と `inst` 式中の束縛変数は、より小さい範囲で再宣言されないかもしれません。
  また、ラムダとlet式とは異なり、 `over` 式と `inst` 式は明示的な型を含まなければなりません;他の式の型は、ここで与えられる規則によって推論されます。

  例えば、図3の中で与えられる等価式の一部の定義は、図6に示されます。
  この図と残りのこの付録において、我々は型 `τ -> τ -> Bool` の省略形として、 `Eq τ` を使います。

  第2の例として、図1の中で与えられる算術演算子の一部の定義は、図7に示されます。
  この数字では、我々は型の省略形として、 `Num τ` を使います。

    (τ -> τ -> τ, τ -> τ -> τ, τ -> τ)

  形式言語に変換する際に、3つの演算子をグループ化して「辞書」にしました。
  これは直接的であり、中心的な問題、すなわちオーバーロードを解決する方法とは独立しています。

## A.2 型

  Damas/Milnerシステムは、(`τ`と書かれている)型と(`σ`と書かれている)型スキームとを区別します。
  我々のシステムでは、述語型の第3の構文グループが追加されています。
  これらの構文は図5に示されています。

    Identifiers       x
    Expressions       e ::= x
                          | e0 e1
                          | λx. e
                          | let a = e0 in e1
                          | over x :: σ in e
                          | inst x :: σ = e0 in e1
    Type variables    α
    Type Constructors χ
    Types             τ ::= (τ -> τ') | α | χ(τ1 ... τn)
    Predicated Types  ρ ::= (x :: τ).ρ | τ
    Type-schemes      σ ::= ∀α.σ | ρ

  図5： 式と型の構文

  フルスペックの言語では、我々は型を以下のように書きました

    member :: Eq a => [a] -> a -> Bool

  簡易な言語では、以下のように書きます

    member :: ∀α. (eq :: Eq α). [α] -> α -> Bool

  制限 `Eq a` は、「等式が型 `a` に定義されている」と解釈され、対応する制限 `(eq :: Eq α)` は「`eq`が型 `Eq α` のインスタンスを持たなければならない」と読むことができます。

  一般に、 `(x :: τ).ρ` を述語型 `(x :: τ)` を述語と呼びます。

  我々は、次の形式の型付けを導出するためのルールを与えます

    A |- e :: σ \ e^

  これは、「一連の仮定 `A` の下では、式 `e` は変換付きの型付きが良い」と読むことができます。
  それぞれのタイピングには変換も含まれているので、ルールは `型 \ 変換` の ペアの形をしています。
  すべてのルールから '`\ e^`' 部分を削除するだけで、変換を参照せずにタイピングルールを提示することができます。
  ただし、入力規則は変換を制御するため、変換規則を単独で表示することはできません。
  例えば、型の述語の導入および排除は、変換におけるラムダ抽象の導入および排除を制御します。

    over eq :: ∀α. Eq α in
    inst eq :: Eq Int = eqInt in
    inst eq :: Eq Char = eqChar in
    inst eq :: ∀α.∀β.(eq :: Eq a).(eq :: Eq β). Eq (α, β)
             = λp. λq. eq (fst p) (fst q) ∧ eq (snd p) (snd q) in
    eq (1, 'a') (2, 'b')

  図6： 形式化された等価性の定義

    over numD :: ∀α. Num α in
    inst numD :: Num Int = (addInt, mulInt, negInt) in
    inst numD :: Num Float = (addFloat, mulFloat, negFloat) in
    let (+) = fst numD in
    let (*) = snd numD in
    let negate = thd numD in
    let square = λx. x * x in
    square 3

  図7： 形式化された算術演算の定義

    (eq ::o ∀α.Eq α),
    (eq ::i Eq Int  \ eq(Eq Int )),
    (eq ::i Eq Char \ eq(Eq Char)),
    (eq ::i ∀α.∀β.(eq :: Eq α).(eq :: Eq β).Eq (α, β) \ eq(∀α.∀β.(eq::Eq α).(eq::Eq β).Eq (α,β)) ),
    (eq :: Eq α \ eq (Eq α)),
    (eq :: Eq β \ eq (Eq β)),
    (p :: (α, β) \ p),
    (q :: (α, β) \ q)

  図8：いくつかの仮定

    TAUT A, (x :: σ \ x^) |- x :: σ \ x^

    TAUT A, (x ::i σ \ x^) |- x :: σ \ x^

         A |- e :: ∀α. σ \ e^
    SPEC -----------------------------
         A |- e :: [α \ τ]σ \ e^

         A |- e :: σ \ e^
         α not free in A
    GEN  -----------------------------
         A |- e :: ∀α. σ \ e^

         A |- e :: (τ' -> τ) \ e^
         A |- e':: τ' \ e'^
    COMB -----------------------------
         A |- (e e') :: τ \ (e^ e'^)

         Ax, (x :: τ' \ x) |- e :: τ \ e^
    ABS  ---------------------------------
         A |- (λx.e) :: (τ' -> τ) \ (λx.e)

         A |- e :: σ \ e^
         Ax, (x :: σ \ x) |- e' :: τ \ e'^
    LET  -----------------------------------------------
         A |- (let x = e in e') :: τ \ (let x = e^ in e'^ )

  図9：タイピングと変換規則(一部1)

## A.3 仮定

  型付けは仮定の集合` A` の文脈で行われます。
  仮定は、型および変換情報を式の自由な識別子に結び付けます。
  これには、lambdaとlet式でバインドされた識別子と、オーバーロードされた識別子が含まれます。
  シーケンスとして書きますが、仮定は集合であるため、順序は関係ありません。

  仮定リストでの束縛には3つの形があります：

  - `(x ::o σ)` は、オーバーロードされた識別子に使用されます;
  - `(x ::i σ \ xσ)` は、オーバーロードされた識別子の宣言されたインスタンスに使用されます; そして
  - `(x ::σ \ x^)` はラムダとlet束縛変数に使用され、オーバーロードされた識別子のインスタンスとみなされます。

  `(x :: σ \ x^)` および `(x ::i σ \ x^)` で、識別子 `x^` は `x` を変換したものです。
  `x` がオーバーロードされた識別子でない場合(つまり、`x`がラムダまたはlet式でバインドされている場合)、仮定は `(x ::σ \ x)` の形式を持つため、 `x`　は単にそれ自体として変換されます。

  図8は、図6の式

    λp. λq. eq (fst p) (fstq) ∧ eq (snd p) (sndq)

  に推論ルールを適用する際に利用できる仮定を示しています。

  3つのインスタンス宣言に対応する3つの `(::i)` バインディングと、2つのバインドされた変数の2つの `(::)` バインディングと、想定される等価インスタンスに対応する2つの `(::)` バインディングがあります。
  (後で PRED ルールによって想定されるインスタンスがどのように導入されるかを見ることにします。)

## A.4 インスタンス

  仮定 `A` の集合が与えられると、次の型スキームとのインスタンス関係を定義します:

    σ >-A σ'

  これは、「`σ` は仮定 `A` の下で `σ`より一般的です」と読むことができます。
  これは、DamasとMilnerによって定義された関係と同じですが、述語型に適用されるように拡張されています。

  特定の一連の仮定のみが有効です。
  妥当性の定義は `>-A` 関係に依存するため、有効な前提の定義と `>-A` の定義の間に(よく確立された)相互再帰があります。
  このセクションでは、 `>-A` の定義を与え、次の節では有効な前提の定義について説明します。

  インスタンス関係

    σ >-A σ'

  ここで `σ = ∀α1 ... αn.ρ` かつ `σ' = ∀β1 ... βm . ρ'` は次のように定義されています:

    σ >-A σ' iff
      (1) βi is not free in σ and
      (2) ∃τ1, ..., τn. [τ1/α1, ..., τn/αn]ρ >-A ρ'

  この部分は Damas/Milner における定義と同様です。
  `σ` の束縛変数は特殊化され、結果として得られる述語型が比較されます。

  `ρ` の型部分の `ρ >-A ρ'`を `ρ'` の型部分(Damas/Milnerと同じ条件)に等しく定義し、`ρ` のすべての述語 `(x :: τ)` について、

  - `ρ'` に `(x :: τ)` という形の述語があります(すなわち、両方の型に述語が現れる); または
  - 述語は仮定 `A` のもとで除去することができます。

  述語 `(x::τ)` は、 `A` のもと以下のいずれかで除去することができます

  - `(x :: τ \ x^)`が `A` にある; または
  - `(x::i σ' \ x^)` が `A` にあり、かつ、 `σ' > A τ`。

  例えば、 `A0` が図8の仮定の集合である場合、

    (∀α. (eq :: Eq α). [a] -> α -> Bool)
        >-A0 ([Int] -> Int –> Bool)

  が成り立ちます。 一方、 `A0` には、 `eq` が型 `Float` のインスタンスを持つことを表明するバインディングが含まれていないため、

    (∀α. (eq :: Eq α). [α] –> α –> Bool)
          >-A0 ([Float] –> Float –> Bool)

  は成り立ちません。

  2つの型スキームは、それらが重複している場合、つまり、いくつかの仮定のセットの両方のインスタンスである型が存在する場合には、単一化可能です。
  `σ` と `σ'` は、型 `τ` が存在し、次のような仮定 `A` の有効な集合が存在する場合、統一的であるといいます。

    σ >-A τ Λ σ' >-A τ

  `σ` と `σ'` が統一的でない場合、 `σ ＃ σ'` と書きます。

         A, (x :: τ \ xτ) |- e :: ρ \ e^
    PRED ---------------------------------- (x ::ο σ) ∈ A
         A |- e :: (x :: τ).ρ \ (λxτ. e^)

         A |- e :: (x :: τ).ρ \ e^
         A |- x :: τ \ e'^
    REL  ------------------------------------ (x ::ο σ) ∈ A
         A |- e :: ρ \ (e^ e'^)

         Ax, (x ::ο σ) |- e :: τ \ e^
    OVER ---------------------------------
         A |- (over x :: σ in e) :: τ \ e^

         A, (x ::i σ' \ xσ') |- e' :: σ' \ e'^
         A, (x ::i σ' \ xσ') |- e  :: τ  \ e^
    INST ----------------------------------------------------------- (x ::ο σ) ∈ A
         A |- (inst x :: σ' = e' in e) :: τ \ (let xσ' = e'^ in e^)

  図10： 型付け規則と変換規則、パート2

    let eq(Eq Int) = eqInt in
    let eq(Eq Char) = eqChar in
    let eq(∀α.∀β.(eq::Eq α).(eq::Eq β). Eq(α, β))
        =  λeq(Eq α).λeq(Εq β).λp.λq.
            eq(Εq α) (fst р) (fst q) /\ eq(Eq β) (snd р) (snd q) in
    eq(∀σ.∀β.(eq::Eq a).(eq::Eq β). Eq (α,β)) eq(Eq Int) eq(Eq Char) (1, 'a') (2, 'b')

  図11： 形式化された等価性の変換

    A1 : (eq ::o ∀α.Eq α)
         (eqInt :: Eq Int \ eqInt)
         (eqChar :: Eq Int \ eqChar)

    e1 : inst eq :: Eq Int = eqInt in
         inst eq :: Eq Char = eqChar in
         eq

  図12： 問題のある式

## A.5 有効な仮定

  証明内で使用される仮定のすべてのセットは有効でなければなりません。
  有効な一連の仮定は、次のように誘導的に定義されます:

  - 空。 空の仮定の集合 `{}`、は有効です。

  - 通常の識別子。 `A` が有効な仮定集合である場合、
    `x` は `A` には現れない識別子であり、
    `σ` は型スキームであり、

        A, (x :: σ \ x)

    は有効な仮定集合です。

  - オーバーロードされた識別子。

    `A` が有効な仮定集合である場合、 `x` は `A` に現れない識別子であり、
    `σ` は型スキームであり、 `τ, ..., τm` は型であり、
    `σ1, ..., σn` は次のような型スキームです:

    - `σ >-A σ'i` 、`1` から `n` までの `i` について、および
    - `σ >-A τi`、 `i` は `1` から `m` まで、
    - `σi # σj`、 異なる `i`、 `j` について `1` から `n` まで

    そして

        A, (r ::ο σ),
        (x ::i σ1 \ xσ1), ..., (x ::i σn \ xσn) ,
        (x ::  τ1 \ xτ1), ..., (x ::  τm \ xτm)

    は有効な仮定集合です。

  例えば、図8の仮定は有効な集合です。
  ただし、このインスタンスが既に集合内にあるインスタンスと重複しているため、バインディング

    (eq ::i ∀γ. Eq(Char, γ) \ eq(∀γ. Eq(Char, γ)) )

  で拡張された場合、この集合は無効になります。

## A.6 推論規則

  現在の以下の形式のwelltypingsを特徴付ける推論規則を与えます

    A |- e :: σ \ e^

  このルールは、図9と図10に示す2つのグループに分かれています。
  最初のグループは Damas/Milner ルールに直接基づいています(図9)。
  2つの小さな違いがあります。トランスレーションが簡単に各ルールに追加され、1つではなく2つのTAUTルールがあります(`(::)` バインディングのルールと `(::i)` バインディングのルール)。

  たとえば、整数と文字定数の種類についての仮定とともに、図8に示す一連の仮定を `A0` とします。
  そして、上記の規則は、以下を導き出すのに十分です:

    A0 |- (eq 1   2  ) :: Bool \ (eq(Eq Int) 1 2)
    A0 |- (eq 'а' 'b') :: Bool \ (eq(Eq Char) 'а' 'b')

  つまり、単純なオーバーロードを解決するにはこれらのルールだけで十分です。

  オーバーロードの複雑な使用には、残りの4つのルールが必要です(図10参照)。
  最初の2つは述語の導入と削除を扱い、後の2つは `over` と `inst` 構文を扱います。

  今まで見てきたように、クラスを含む型を持つ式(つまり、述語型を持つ式)は、実行時に辞書を渡す必要があるラムダ抽象化に変換されます。
  この考え方は、PRED("predicate")ルールとREL("release")ルールにカプセル化されています。
  PREDルールとRELルールは、GENとSPECルールがバインドされた型変数を導入し排除する方法と同様に述語を導入し、除去します。
  特に、PREDルールは述語を型に追加し(その変換としてラムダ式を持ちます)、RELルールは型から述語を削除します(変換としてアプリケーションを持ちます)。

  OVERルールは、適切な `(::o)` バインディングを環境に追加する式に、適切な `(::i)` バインディングを環境に追加するINSTルール型のinst式を入力します。
  仮定集合に対する妥当性条件は、オーバーロードされた識別子が有効な型でのみインスタンス化されることを保証します。

  いずれの変換も `over` 式または `inst` 式を含んでいないので、オーバーロードは含まれていません。
  Hindley/Milnerシステムでは、変換自体が適切に型付けされていることを確認するのは簡単です。

  たとえば、図6のプログラムは、これらの規則によって図11のプログラムに変換されます。
  読者は、これが図3から図4の変換に対応していることを容易に確認することができます。
  我々はこのように、論文の本文に非公式に提示されたタイピングと変形の考え方をどのように形式化するかを示しました。

## A.7 主要型付け

  `A` と `e` が与えられたとき、我々は `σ` を `A` のもとでの `e` の主要な型スキームと呼び

  - `A |- e :: σ \ e^` ; かつ
  - すべての `σ'` について、 `A |- e :: σ' \ e'^` ならば `σ >-A σ'` です。

  Hindley/Milnerシステムの鍵となる結果は、well-typingなすべての式 `e` が主要型スキームであることです。

  我々は、すべての有効な一連の仮定 `A` およびすべての式 `e` が `over` または `inst` 式を含まない場合、 `e` が `A` の下で型どりの良いものであれば、 `e` は `A` のもとで主要型スキームを持つと推論します。

  たとえば、 `A0` は図8の仮定の集合とします。
  そして、型付け

    A0 |- eq :: ∀α. Eq a \ eq(Eq alpha)

  は主要です。
  主要でない型付けの例は

    A0 |- eq :: Eq Int  \ eq(Eq Int)
    A0 |- eq :: Eq Char \ eq(Ep Char)

  です。これらのそれぞれは、仮定 `A0` のもとでの主要型付けのインスタンスです。

  主要型の存在は、 `over` 式と `inst` 式を含む式では問題になります。
  たとえば、図12の仮定集合と式を `A1` と `e1` とします。
  そして、次の型付けを導出することが可能です

    A1 |- e1 :: Eq Int  \ eqInt
    A1 |- e1 :: Eq Char \ eqChar

  しかし、ここに主要型はありません！
  これの可能な解決方法の1つは、 `over` 宣言とグローバル宣言にグローバルスコープが必要であることです。
  主要型の存在を確実にする、それほど劇的ではない制限があるかどうかは未解決のままです。

## References

  <a name="BEJ88"></a>[\[BEJ88\]](#r_BEJ88) D. Bjørner, A. Ershov, and N.D. Jones, editors, Partial Evaluation and Mired Computation, North-Holland, 1988 (to appear).

  <a name="CW85"></a>[\[CW85\]](#r_CW85) L. Cardelli and P. Wegner, On understanding types, data abstraction, and polymorphism. Computing Surveys 17, 4, December 1985.

  <a name="Car88"></a>[\[Car88\]](#r_Car88) L. Cardelli, Structural subtyping and the notion of power type. In Proceedings of the 15th Annual Symposium on Principles of Programming Languages, San Diego, California, January 1988.

  <a name="DM82"></a>[\[DM82\]](#r_DM82) L. Damas and R. Milner, Principal type schemes for functional programs. In Proceedings of the 9th Annual Symposium on Principles of Programming Languages, Albuquerque, N.M., January 1982.

  <a name="FGJM85"></a>[\[FGJM85\]](#r_FGJM85) K. Futasagi, J.A. Goguen, J.-P. Jouannaud, and J. Meseguer, Principles of OBJ2. In Proceedings of the 12th Annual Symposium om Principles of Programming Languages, January 1985.

  <a name="GR83"></a>[\[GR83\]](#r_GR83) A. Goldberg and D. Robson, Smalltalk80: The Language and Its Implementation. Addison-Wesley, 1983.

  <a name="Hin69"></a>[\[Hin69\]](#r_Hin69) R. Hindley, The principal type scheme of an object in combinatory logic. Trans. Am. Math. Soc. 146, pp. 29—60, December 1969.

  <a name="HMM86"></a>[\[HMM86\]](#r_HMM86) R. Harper, D. MacQueen, and R. Milner, Standard ML. Report ECS-LFCS-86-2, Edinburgh University, Computer Science Dept., 1986.

  <a name="HMT88"></a>[\[HMT88\]](#r_HMT88) R. Harper, R. Milner, and M. Tofte, The definition of Standard ML, version 2. Report ECS-LFCS-88-62, Edinburgh University, Computer Science Dept., 1988.

  <a name="Kae88"></a>[\[Kae88\]](#r_Kae88) S. Kaes, Parametric polymorphism. In Proceedings of the 2'nd Furopean Symposium on Programming, Nancy, France, March 1988, LNCS 300, Springer-Verlag, 1988.

  <a name="Mil78"></a>[\[Mil78\]](#r_Mil78) R. Milner, A theory of type polymorphism in programming. J. Comput. Syst. Sci. 17, pp. 348–375, 1978.

  <a name="Mil84"></a>[\[Mil84\]](#r_Mil84) R. Milner, A proposal for Standard ML. In Proceedings of the Symposium on Lisp and Functional Programming, Austin, Texas, August 1984.

  <a name="Mil87"></a>[\[Mil87\]](#r_Mil87) R. Milner, Changes to the Standard ML core language. Report FCS-LFCS-87-33, Edinburgh University, Computer Science Dept., 1987.

  <a name="MP85"></a>[\[MP85\]](#r_MP85) J. C. Mitchell and G. D. Plotkin, Abstract types have existential type. In Proceedings of the 12th Annual Symposium on Principles of Programming Languages, January 1985.

  <a name="Rey85"></a>[\[Rey85\]](#r_Rey85) J. C. Reynolds, Three approaches to type structure. In Mathematical Foundations of Software Development, LNCS 185, Springer-Verlag, 1985.

  <a name="Str67"></a>[\[Str67\]](#r_Str67) C. Strachey, Fundamental concepts in programming languages. Lecture notes for International Summer School in Computer Programming, Copenhagen, Allgust 1967.

  <a name="Tur85"></a>[\[Tur85\]](#r_Tur85) D. A. Turner, Miranda: A non-strict functional language with polymorphic types. In Proceedings of the 2'nd International Conference on Functional Programming Languages and Computer Architecture, Nancy, France, September 1985. LNCS 201, Springer-Verlag, 1985.

  <a name="Wan87"></a>[\[Wan87\]](#r_Wan87) M. Wand, Complete type inference for simple objects. In Proceedings of the Symposium on Logic in Computer Science, Ithaca, NY, June 1987. IEEE Computer Society Press, 1987.
