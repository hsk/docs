# 関数型言語としてのGNU Prolog入門

Prologは論理型言語です。論理型言語の特徴はパターンマッチを双方向に行う単一化の機能です。
パターンマッチは関数型言語の便利な機能の一つですが、それを更に強力にした機能をPrologはもっています。
この文章では、Prologを関数型言語として用いてパターンマッチを利用したプログラミングを行い、徐々にPrologの理解を深めて行きます。
関数型言語が得意ならPrologは簡単なはずです。が、読めないので読めるようになろうということで、勉強して行きたいと思います。

Hello Worldを書きたい。ファイルをコンパイルして実行ファイルを作りたい。
ファイルを読み込んで出力したい。ファイルを書き出したい。
ファイルを読み込んで文字列処理をしたい。
足し算や引き算をしたい。まず普通のプログラミング言語として使いたいのです。
普通のプログラミング言語としてPrologを使うように、入門したいと思います。

TODO: 誰かの誰かな批判はよくない。

## インストール

インストールはMacのHomebrewを使っている場合は、gprologをインストールします。

	$ brew install gnu-prolog

swi-prologを使う場合は

	$ brew install swi-prolog

Windowsでは、Cygwinをつかってgprologをインストールしましょう。


## インタプリタの実行と終了

gprologでインタプリタが起動出来ます。

	$ gprolog
	GNU Prolog 1.4.4 (64 bits)
	Compiled Nov 11 2014, 17:24:08 with clang
	By Daniel Diaz
	Copyright (C) 1999-2013 Daniel Diaz
	| ?- halt.
	$

とりあえず、終了するには、halt.です。exitでも、byeでもquitでもありません。
haltという述語で終了出来ます。述語は.で終了出来ます。.はC言語やJava、JavaScriptなどの;です。.を省略することは出来ません。

## インタプリタで、Hello World!

write('hello world').と書くことで文字列を出力することが出来ます。
writeはwrite/1の述語です。/1は引数の数を表します。

	$ gprolog
	GNU Prolog 1.4.4 (64 bits)
	Compiled Nov 11 2014, 17:24:08 with clang
	By Daniel Diaz
	Copyright (C) 1999-2013 Daniel Diaz
	| ?- write('hello world').
	hello world

	yes
	| ?- halt.
	$

インタプリタでは様々な述語を使うことが出来ます。

## ファイルのコンパイル

さて、ファイルを読み込んでコンパイルしてみましょう。
以下のファイルをhello.plとして保存します。

	/* gplc hello.pl */

	:- initialization(main).
	main :-
		write('Hello World!'), nl,
		halt.

これは素で書けるように、毎日10回くらい書く等して頭に叩き込むと良いでしょう。

initialization/1を使うことで自動的に処理を開始することが出来ます。
nlは改行を出力し、haltで終了します。
このように述語は,で複数繋げて記述することが出来ます。
また、:-を使って述語を定義することが出来ます。
文字列は''で括って表します。
以下のgplcコマンドでコンパイルします。

	$ gplc hello.pl
	$ ./hello
	Hello World!
	$

コンパイルすると、拡張子を除いた同名の実行ファイルが生成されます。
haltしないプログラムの場合はインタプリタが起動します。

## 述語

引数を持つ述語を定義すれば、関数のようなことが出来ます。
例えば足し算をするだけの述語add/3は以下のように定義して使うことが出来ます。

	/* gplc add.pl; ./add */

	add(A, B, R) :-
	  R is A + B.

	:- initialization(main).
	main :-
	  add(10, 20, X),
	  write(X), nl,
	  halt.

isという述語を使うと数値計算も出来ます。
Prologは、関数はなくて、述語があるだけです。関数が値を返すということは基本的に出来ません。
関数の要な事をしたい場合は、述語を使って帰り値をリファレンスを使って受け取るようにする事で可能です。

	$ gplc add.pl
	$ ./add
	30
	$


実際には、prologのプログラムは単一化によって事実関係を正しく合わせるという操作が行われています。
addのAとBが与えられていて、Rが分からないのでRは何かというとA+BなのでA+Bを計算してRが求まるわけです。
変数は大文字で始まる識別子です。小文字で始まる識別子はアトムといいます。

## リスト

リストを使ってみましょう。
1から5までの合計を出力するには、例えば以下のようにします。

	/* glpc list.pl; ./list */

	sum([],R) :- R is 0.
	sum([X|XS], R) :-
		sum(XS, R1),
		R is X + R1.

	:- initialization(main).

	main :-
		sum([1,2,3,4,5], R),
		write('Result = '), write(R), nl,
		halt.

sumという述語を作り、リストの中味が空なら0です。
また、リストを受け取って手前と後ろを[X|XS]のようにしてパターンマッチし分けて考え、Xの値とXSの合計値を足す再帰的な述語を書けば、再帰関数のように使うことが出来ます。
main関数でsumを使って合計を求め、出力すれば出来上がりです。
関数型言語を知っていれば難しい事は無いはずです。

## 四則演算

言語作り好きなので、四則演算をPrologで作ってみたいと思います。
evalという述語を作って、int(1)やadd(int(1),int(2))等を受け取って結果を返すことをしようと思います。

	eval(int(A),R) :- R is A.
	eval(add(A,B),R) :- eval(A,A2), eval(B,B2), R is A2 + B2.
	eval(sub(A,B),R) :- eval(A,A2), eval(B,B2), R is A2 - B2.
	eval(mul(A,B),R) :- eval(A,A2), eval(B,B2), R is A2 * B2.
	eval(div(A,B),R) :- eval(A,A2), eval(B,B2), R is A2 / B2.

	:- initialization(main).
	main :-

	  eval(add(mul(int(10),int(20)),int(20)), X),
	  write('10 * 20 + 20 = '), write(X), nl,
	  halt.

関数型言語では、addやint等の定義が必要ですが、Prologでは必要ありません。
Prologでは全ての式は只のデータにすぎません。int(10)というのも只のデータです。その只のデータを受け取って、Rの変数が辻褄が合うように整合性を合わせる計算をすると結果が求まるだけです。
なので、データの定義をすることなく自然に式を扱ったプログラムが出来ます。素晴しい。

## 四則演算を記号を使って作成する

PrologではA+Bと行った式もまたデータにすぎません。
したがって、足し算の計算もパターンマッチを使って記述することが出来ます。

	eval(int(A),R) :- R is A.
	eval((A+B),R) :- eval(A,A2), eval(B,B2), R is A2 + B2.
	eval((A-B),R) :- eval(A,A2), eval(B,B2), R is A2 - B2.
	eval((A*B),R) :- eval(A,A2), eval(B,B2), R is A2 * B2.
	eval((A/B),R) :- eval(A,A2), eval(B,B2), R is A2 / B2.

	:- initialization(main).
	main :-
	  eval((int(10) * int(20) + int(20)), X1),
	  write('10 * 20 + 20 = '), write(X), nl,
	  halt.

２項演算子を使った場合は、()を使わないとエラーになるようです。理由はよくわかりませんが、演算子の優先順位の問題なのかもしれないし、そうでないかもしれません。
素人なので分かりませんが、とにかく困ったら()で括ればうまくいきますw

## 演算子定義を使った四則演算

Prologでは演算子を定義して使うことが出来ます。
例えば、op(1200, xfx, [ => ])は左結合演算子の=>を優先順位1200で登録できます。
=>演算子をevalの代わりに使えば、以下のように四則演算を定義することが出来ます。

Prologの演算子の桁はやたらデカいのですが、おそらく、演算子を沢山追加した場合に間に挟むことが出来るように余裕を持たせたためではないかと思います。

	:- op(1200, xfx, [ => ]).
	(A => R) :- R is A.
	((A+B) => R) :- (A => A2), (B => B2), R is A2 + B2.
	((A-B) => R) :- (A => A2), (B => B2), R is A2 - B2.
	((A*B) => R) :- (A => A2), (B => B2), R is A2 * B2.
	((A/B) => R) :- (A => A2), (B => B2), R is A2 / B2.

	:- initialization(main).
	main :-
	  (10 * 20 + 20 => X2),
	  write('10 * 20 + 20 => '), write(X2), nl,
	  halt.

## パーサを作ろう!

四則演算の演算が出来たら、ファイルを読み込んでパースして、パース結果を実行したいのが言語マニアの願う所です。
ググってパーサのソースコードを見て理解できないので理解していきましょう。
まずは、Prologでは文字列をリストで表してリストからトークン列を作り、トークン列から構文木を作ってみましょう。
構文木を作れれば、先ほど作ったevalで実行出来ます。
そこで、簡単なコンパイラを考えると出来上がった構文木とevalがあるprologのコードをファイルに出力し、ファイルをコンパイルすれば
コンパイラとなるはずです。また、Prologを関数型言語として使うのであれば、パーサコンビネータも作ってパーサコンビネータを用いてパーサを作ることも考えてみたい所です。
パーサコンビネータは、関数が値を返さないと難しいかもしれませんがw

### 文字列をリストで表す。

	/* gplc strlist.pl ; ./strlist */
	:- initialization(main).
	main :-
	  write("10 * 20 + 20"), nl,
	  halt.

Prologでは""で括った文字列はリストとして扱われます。"10 * 20 + 20"は

	[49,48,32,42,32,50,48,32,43,32,50,48]

というリストになります。

### 文字列をパターンマッチして数値を取り出す。

	integer([A | B], C, S, R * 10) :-
		P is A - 0'0,
		P >= 0,
		P =< 9,
		(
			integer(B, C, Q, R),
			S is P * R + Q;
			B = C,
			S = P,
			R = 1
		).

### ファイルを読み込む

そいういうことで、ファイルを読み込んで表示してみましょう。

## パーサコンビネータを作る

TODO

## 型推論

https://github.com/kyagrd/HMtyInferUsingProlog

は色々あって素晴しいです。

## 1から10の合計を求めてみる

TODO

## fib 10を計算する

TODO
